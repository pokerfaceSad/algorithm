1. 二进制数`n`和`n-1`求与`&`，会消掉最后一位的1，可用于求二进制数中1的个数，循环与n-1相与直至为0
2. 将数字分解成多个数的积，如何分解积最大？尽量分解出更多的3，特殊情况是剩下一个4时不再分，初始数字小于4时结果为n-1
3. 摩尔投票法求数组中的众数（超过一半）
4. `istringstream`和`ostringstream`可用于处理字符串的频繁操作，`# include <sstream>`
5. 旋转左移或右移数组或字符串可以采用三次旋转的方法实现，`# include <algorithm> reverse()`
6. 二维非严格排序数组（从左向右递增、从上到下递增）的查找，从右上角开始，大于目标向左移动，小于目标向下移动
7. 字符串中所有空格替换成“%20”，先统计空格数量，`resize()`扩展字符串长度然后从后向前填充新字符串
8. ⭐根据前序遍历和中序遍历重建二叉树（无重复值），根据前序遍历的首字符得到根节点的值，根据根节点的值将中序遍历序列分为左右两个子树的中序遍历子序列，根据新的中序遍历子序列的长度得到两个新的前序遍历子序列，由于需要多次查询根节点在中序遍历中的位置，需预先采用哈希表将中序遍历中的值和索引进行映射
9. 两个栈实现队列的先进先出，一个栈负责压入数据，另一个栈负责弹出数据，弹出栈为空时将数据栈中的所有数据倒入弹出栈，“倒入”的过程实现了数据的逆置
10. 动态规划的三个要素：`dp`状态的定义、`dp[n-1]`到`dp[n]`的递推、最小子问题的解（`dp`的初始值）
11. 循环求余法：`(x + y)  % n = x % n + y % n`
12. 旋转递增数组中的最小数字，二分查找:

    * `nums[high] > nums[mid]`时`high = mid`

    * `nums[high] < nums[mid]`时`low = mid+1`

    * `nums[high] == nums[mid]`时`high--`
13. 矩阵中的路径，`dfs`深搜寻路，将走过的进行标记，回溯时恢复，可以节省一个`vis`矩阵
14. 机器人的运动范围，动态规划，要想到达某一个格子，只能从上方或者左侧移动而来`dp[i][j] = (dp[i-1][j] || dp[i][j-1]) &&  getSum(i, j)`
15. `n&1`可用于判断最后一位是0还是1，也可以判断n是奇数还是偶数
16. 快速幂，`myPow(x, n)`

    * 如果n是奇数，`myPow(x, n) = myPow(x, n-1)`
    * 如果n是偶数，`myPow(x, n) = myPow(x*x, n/2)`
    * 如果n小于0，`myPow(x, n) = 1/x * myPow(1/x, -(n+1))`
    * 如果n等于0，最小情况，返回1
17. 正则表达式`p`匹配字符串`s`，动态规划：

    * 定义：`dp[i][j]`表示前`i`个字符`s[:i]`能否和前`j`个正则表达式`p[:j]`匹配
    * 递推关系：
      * `s[i] == p[j] || p[j] == '.' -> dp[i][j] = dp[i-1][j-1]`
      * `p[j] == '*' && s[i] != p[j-1] -> dp[i][j] = dp[i][j-2] `
      * `p[j] == '*' && (s[i] == p[j-1] || p[i] == '.') -> dp[i][j] = dp[i-1][j] || dp[i][j-2]`  `dp[i][j-2]`代表的情况为能匹配，但是不匹配
    * 初始值：`dp[0][0] = 1`表示空字符串可以匹配空模式串，其他`dp[x][0] = 0`表示空模式串没法匹配任何非空字符串
18. 反转链表，将链表分为已反转和待反转两个部分
19. 判断一个二叉树是否为对称二叉树，可以借助一个队列，对左右子树同时进行`bfs`
20. 顺时针打印矩阵，右下左上转圈打印，每打印一边后根据输出的元素数量判断是否结束
21. 判断是否是栈可能的弹出序列，栈中元素不重复，用一个栈来模拟压栈过程，每压一个判断栈顶元素是否弹出序列的对应的元素，如果是则弹出，如不是则继续压，若能全部顺利弹出则是可能的弹出序列
22. 按层打印二叉树，在借助队列进行`bfs`的基础上，每层打印时添加一个循环，根据队列中元素的数量判断该层的元素数量
23. 判断一个序列是否是二叉搜索树的后序遍历序列，根据二叉搜索树的属性，一个节点的左子树的所有节点值都小于父节点的值，右子树的所有节点值都小于父节点的值。取序列的最后一个元素，从序列左侧开始查找所有小于最后一个元素值得子序列作为左子树的后序遍历序列，剩下的即为右子树的后序遍历序列，依次判断右子树的后序遍历序列是否都小于根节点的值，如果都小于的话递归继续判断左右子树的后序遍历序列是否合法
24. 二叉搜索树转换为双向递增链表，中序遍历，用一个指针保存前驱节点，另一个指针保存头节点，递归处理左子树之后，将当前节点与前驱节点双向连接，然后递归右子树，最后将前驱节点与头节点双向连接
25. 序列化与反序列化二叉树，序列化采用`bfs`但是需要将叶子节点的空左右指针保存，反序列化时同样采用`bfs`
26. 字符串的全排列

