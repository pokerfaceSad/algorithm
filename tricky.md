1. 二进制数`n`和`n-1`求与`&`，会消掉最后一位的1，可用于求二进制数中1的个数，循环与n-1相与直至为0
2. 将数字分解成多个数的积，如何分解积最大？尽量分解出更多的3，特殊情况是剩下一个4时不再分，初始数字小于4时结果为n-1
3. 摩尔投票法求数组中的众数（超过一半）
4. `istringstream`和`ostringstream`可用于处理字符串的频繁操作，`# include <sstream>`
5. 旋转左移或右移数组或字符串可以采用三次旋转的方法实现，`# include <algorithm> reverse()`
6. 二维非严格排序数组（从左向右递增、从上到下递增）的查找，从右上角开始，大于目标向左移动，小于目标向下移动
7. 字符串中所有空格替换成“%20”，先统计空格数量，`resize()`扩展字符串长度然后从后向前填充新字符串
8. ⭐根据前序遍历和中序遍历重建二叉树（无重复值），根据前序遍历的首字符得到根节点的值，根据根节点的值将中序遍历序列分为左右两个子树的中序遍历子序列，根据新的中序遍历子序列的长度得到两个新的前序遍历子序列，由于需要多次查询根节点在中序遍历中的位置，需预先采用哈希表将中序遍历中的值和索引进行映射
9. 两个栈实现队列的先进先出，一个栈负责压入数据，另一个栈负责弹出数据，弹出栈为空时将数据栈中的所有数据倒入弹出栈，“倒入”的过程实现了数据的逆置
10. 动态规划的三个要素：`dp`状态的定义、`dp[n-1]`到`dp[n]`的递推、最小子问题的解（`dp`的初始值）
11. 循环求余法：`(x + y)  % n = x % n + y % n`
12. 旋转递增数组中的最小数字，二分查找:

    * `nums[high] > nums[mid]`时`high = mid`

    * `nums[high] < nums[mid]`时`low = mid+1`

    * `nums[high] == nums[mid]`时`high--`
13. 矩阵中的路径，`dfs`深搜寻路，将走过的进行标记，回溯时恢复，可以节省一个`vis`矩阵
14. 机器人的运动范围，动态规划，要想到达某一个格子，只能从上方或者左侧移动而来`dp[i][j] = (dp[i-1][j] || dp[i][j-1]) &&  getSum(i, j)`
15. `n&1`可用于判断最后一位是0还是1，也可以判断n是奇数还是偶数
16. 快速幂，`myPow(x, n)`

    * 如果n是奇数，`myPow(x, n) = myPow(x, n-1)`
    * 如果n是偶数，`myPow(x, n) = myPow(x*x, n/2)`
    * 如果n小于0，`myPow(x, n) = 1/x * myPow(1/x, -(n+1))`
    * 如果n等于0，最小情况，返回1
17. 正则表达式`p`匹配字符串`s`，动态规划：

    * 定义：`dp[i][j]`表示前`i`个字符`s[:i]`能否和前`j`个正则表达式`p[:j]`匹配
    * 递推关系：
      * `s[i] == p[j] || p[j] == '.' -> dp[i][j] = dp[i-1][j-1]`
      * `p[j] == '*' && s[i] != p[j-1] -> dp[i][j] = dp[i][j-2] `
      * `p[j] == '*' && (s[i] == p[j-1] || p[i] == '.') -> dp[i][j] = dp[i-1][j] || dp[i][j-2]`  `dp[i][j-2]`代表的情况为能匹配，但是不匹配
    * 初始值：`dp[0][0] = 1`表示空字符串可以匹配空模式串，其他`dp[x][0] = 0`表示空模式串没法匹配任何非空字符串
18. 反转链表，将链表分为已反转和待反转两个部分
19. 判断一个二叉树是否为对称二叉树，可以借助一个队列，对左右子树同时进行`bfs`
20. 顺时针打印矩阵，右下左上转圈打印，每打印一边后根据输出的元素数量判断是否结束
21. 判断是否是栈可能的弹出序列，栈中元素不重复，用一个栈来模拟压栈过程，每压一个判断栈顶元素是否弹出序列的对应的元素，如果是则弹出，如不是则继续压，若能全部顺利弹出则是可能的弹出序列
22. 按层打印二叉树，在借助队列进行`bfs`的基础上，每层打印时添加一个循环，根据队列中元素的数量判断该层的元素数量
23. 判断一个序列是否是二叉搜索树的后序遍历序列，根据二叉搜索树的属性，一个节点的左子树的所有节点值都小于父节点的值，右子树的所有节点值都小于父节点的值。取序列的最后一个元素，从序列左侧开始查找所有小于最后一个元素值得子序列作为左子树的后序遍历序列，剩下的即为右子树的后序遍历序列，依次判断右子树的后序遍历序列是否都小于根节点的值，如果都小于的话递归继续判断左右子树的后序遍历序列是否合法
24. 二叉搜索树转换为双向递增链表，中序遍历，用一个指针保存前驱节点，另一个指针保存头节点，递归处理左子树之后，将当前节点与前驱节点双向连接，然后递归右子树，最后将前驱节点与头节点双向连接
25. 序列化与反序列化二叉树，序列化采用`bfs`但是需要将叶子节点的空左右指针保存，反序列化时同样采用`bfs`
26. 字符串的全排列，通过字符交换实现全排列，首先固定第一位字符（第1位字符与第1至n个字符交换，共n重情况）、再固定第2位字符（n-1种情况）、... 、最后固定第n位字符。需要注意剪枝，要保证结果不出现重复字符，则某一层进行字符交换时，不能与已经交换过的字符进行交换。
27. 求一个数组中最小的k个数，采用优先队列进行解决：
    * `priority_queue<int, vector<int>, less<int>> q` 大顶堆 大的元素在顶部，先将前k个元素插入堆中，插入后续元素时若大于堆顶元素不插入，若小于堆顶元素则将堆顶元素弹出并插入，最后返回在堆中的元素
    * `priority_queue<int, vector<int>, greater<int>> q` 小顶堆 小的元素在顶部
28. 实时求数据流中的中位数，借助两个堆，一个大顶堆存放较小的一半，一个小顶堆存放较大的一半
    * 如果两个堆元素数量相同，则先插入小顶堆，再将小顶堆堆顶元素弹出并插入大顶堆
    * 若数量不同，则插入大顶堆，再将大顶堆堆顶元素弹出并放入小顶堆
    * 求中位数时，若两个堆元素数量相同则返回两个堆顶值的平均数，若两个堆元素数量不同则返回大顶堆堆顶元素
29. 连续子数组最大和，动态规划，`dp[i]`表示以`nums[i]`结尾的子数组的最大和，`dp[i] = max(dp[i-1]  + nums[i], nums[i])`，结果为`dp[i]`的最大值
30. 数字序列中的某一位数字，首先找到是几位数，然后判断是第几个数，然后找到数位
31. 把数组排成最小的数，进行排序，比较大小的规则为若 `xy > yx`则`y<x`
32. 把数字翻译成字符串的方案数，动态规划，`dp[i]`表示前`i`个字符组成的子串的翻译方案数，`dp[i] = isMakeSense(s[i-1:i]) ? dp[i-1] : dp[i-1] + dp[i-2]`
33. 最长不含重复字符的子字符串，用一个哈希表存储已经遍历过的字符的索引，动态规划`dp[i]`表示`s[:i]`不重复子串长度，如果`s[i]`在哈希表中出现过且在`dp[i-1]`范围内，`dp[i] = i - hash[s[i]`，否则`dp[i] = dp[i-1] + 1`
34. 丑数，从第一个丑数1开始，对每一个丑数乘2、乘3、乘5即可得到所有的丑数，为了有顺序的输出，将乘2、乘3、乘5分成三种情况考虑，a、b、c分别表示2、3、5正在与第几个丑数相乘，每次取相乘后最小的数输出
35. 数组中的逆序对，对数组进行归并排序，回溯合并子数组的过程中如果出现左侧第`i`个元素大于右侧第`j`个元素的情况，则右侧这个元素可以和左侧`i`右边剩下的所有元素组成逆序对，即`res += (mid - i) + 1`
36. 寻找两个链表的第一个公共节点，双指针同时从两个表头开始出发，到达链表尾部时重新从另一个表头出发，两个指针交汇时即为公共节点
37. 判断一个二叉树是否为平衡二叉树，递归求左右子树的深度，如果左右子树深度差大于一时进行剪枝
38. 数组中只出现一次的数字，其他的数字都出现了两次
    * 如果只有一个这样的数字，所有元素进行异或运算，最后的结果就是只出现一次的元素
    * 如果有两个这样的数字，设为a和b，所有元素即可得到`a^b`，找到`a^b`中为1的一位，说明这一位上a与b是相异的，按照这位是1还是0，将整个数组分为两组，这两组数分别进行异或运算最后得到a和b的值
39. 数组中只出现一次的数字，其他的都出现了三次，统计所有数字32个二进制位上1出现的次数，将这个次数对3取余，最后剩下的数字数字组成的数就是只出现一次的数
40. 滑动窗口的最大值，通过双端队列来维护一个非严格递减的滑动窗口，如果待插入的元素小于等于队尾元素，则直接插入，如果待插入的元素大于队尾的元素，则一直从队尾弹出元素直到队列为空或者待插入元素已经小于等于队尾元素（因为这些被弹出的元素将不会影响最大值的结果），弹出元素时判断队首元素是否等于待弹出元素，若等于则弹出
41. n个骰子所有可能出现点数和的概率，动态规划，`dp[i][j]`表示`i`个骰子点数之和为`j`的概率，`dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + dp[i-1][j-3] + ... + dp[i-1][j-6]`，n个筛子所有可能情况的总数为 `pow(6, n)`
42. 不用if else等关键字计算`1+2+...+n`，可以使用&&短路与当作`if`使用
43. 不使用加减乘除符号做加法，
    * 从二进制角度考虑`a+b = 无进位和 + 进位和`
    * `无进位和 = a ^ b`
    * `进位和 = (a & b) << 1`
    * 注意不能给有符号数做左移，因此需要先将`int`转为`unsigned int`
44. 字符串转整数，从左向右依次读取字符，`res = res * 10 + str[i]`，需要注意的是越界问题
    * 判断是否会越下界，`res < INT_MIN/10 || (res == INT_MIN/10 && -(str[i] - '0') < INT_MIN % 10)`
    * 判断是否会越上界，`res > INT_MIN/10 || (res == INT_MAX/10 && str[i] - '0' > INT_MAX % 10)`
45. 二叉树的最近公共祖先，深度优先搜索，分别在左边和右边都寻找两个目标节点，如果找到一个就直接剪枝返回，根据另一边的结果判断另一个目标节点的位置
46. 实现一个能够得到最小值的栈，用两个栈来实现，一个正常存储元素，另一个只存储最小值，压入元素时如果元素小于等于最小栈栈顶元素，则压入最小栈，弹出元素时如果待弹出元素等于最小栈栈顶元素则最小栈也进行一次弹出

